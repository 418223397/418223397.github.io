#### Week 4 

1. 装饰器 ： **@**

   - 装饰器只是**语法糖**

   - 装饰器的一大特征是将被装饰的函数替换成其他函数

   - 装饰器在加载模块时就立即执行（执行时间）

   - 使用`funtools.wraps`装饰器： 装饰器会把相关的属性（_ _ name__ , _ _doc__) 复制到被装饰函数中

   - 叠放装饰器：从下往上执行

   - 参数化的装饰器：工厂函数，必须要调用

     （vs code: 整体缩进：鼠标选中代码+`Tab`; 反向缩进：`Tab`+`Shift`

- 作业：

  通过递归实现阶乘并通过装饰器打印出每一次递归调用的时长

  

2. 类与实例
   - **面向对象编程**: (OOP)
     - `class`
     - 类中定义的方法来实现某些功能，这些方法通常是类通用的行为
   - 方法(method) vs. 函数(function)
     - 定义位置：
       - 函数：`.py`文件中
       - 方法：`class`类别中
     - 定义方式：
       - 函数：可以无参数
       - 方法：必须带一个默认的参数`self`(静态方法除外/类方法)、
     - 调用方法：
       - 函数: 直接通过函数名调用
       - 方法：通过对象点方法 `object.method`形式调用
   - 类的作用：封装数据和行为成类的属性与方法（将具体的操作抽象成类）

- 作业：如何理解面向对象编程；类与实例间的关系

  

3. 继承与多态：类之间是可以继承的

   - 子类: 可以重写，覆盖父类相同方法

   - 父类（superclass):

   - 多态：同一类型的对象，调用同一个方法，表现出不同的行为 （通过继承与重写）

   - 子类如何调用父类的方法：`super()`

     - 菱形问题：

       -  c3算法类解决

       - 方法解释顺序 （MRO: method resolution order)

         ```
         D.__mro__
         (__main__.D,
          __main__.B,
          __main__.c,
          __main__.A,
          object)
         ```

         ( vs code 批量注释：`ctrl`+`/`)

   - 问题：个人对继承和多态的理解

     

4.  Python 的静态方法与类方法

   - 实例方法

     ```
     class MyClass:
           def instance_method(self,a,b):
               print('实例方法'，a)
     ```

     

   - 类方法 (使用装饰器)

     ```
     @classmethod
     def class_method(cls):
         print('类方法', cls)
     ```

     

   - 静态方法：为了约束在某个类下面，更规范化

     ```
     @staticmethod
     def static_method():
         print('静态方法')
     ```

- 三者间的区别：

  - 自由度
  - 静态方法被约束在类中，让代码更加规范

  **作业**

- 实现一下上面的类方法与静态方法

  

3. 迭代器与生成器

   - 概念

     - 迭代器模式 (Iterator Pattern)：惰性的获取数据，按需获取一个数据项
     - 可迭代对象：`iter`(内置函数)：实现`__getitem__`**或**`__iter__`两个方法的对象
     - 迭代器：实现`__iter__`**和**`__next__`两个方法的对象。其中`__iter__`方法返回迭代器本身，`__next__`方法返回下一个元素。

   - 对应的魔术方法：`next()和Stopiteration`

   - 两者的区别：python会从可迭代对象中获取迭代器

     

​    